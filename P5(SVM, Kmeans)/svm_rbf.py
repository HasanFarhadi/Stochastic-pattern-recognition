# -*- coding: utf-8 -*-
"""SVM_RBF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B22_OIj5oAbWpUpIeQLAAhSm-2S-J1gn
"""

#importing essential libraries and normalizing the data
import numpy as np
from scipy.io import loadmat
from sklearn.svm import SVC
import pandas as pd
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import RepeatedKFold
import matplotlib.pyplot as plt
from sklearn import preprocessing

"""
data = np.loadtxt('/content/drive/MyDrive/Depo/PatternHW/hw5/Health.dat').astype(int)
"""

data = loadmat("/content/drive/MyDrive/Depo/PatternHW/hw5/Dataset2.mat")

input = data["X"]
label = data["y"].reshape(-1)

"""
min_max_scaler = preprocessing.MinMaxScaler()
input = min_max_scaler.fit_transform(data[:, :13])

label = data[:, 13]
"""

#best model parameters to separate the data
def Best_Parameters(input, label):
    Cs = [0.01, 0.04, 0.1, 0.4, 1, 4, 10, 40]
    gammas = [2e-5, 8e-5, 2e-4, 8e-4, 2e-3, 8e-3, 2e-2, 8e-2]
    best_c = 0.01
    best_gamma = 2e-5
    best_acc = 0
    accs = []
    vars = []
    for c in Cs:
        for gamma in gammas:
            model = SVC(kernel='rbf', C=c, gamma=gamma)
            rkf = RepeatedKFold(n_splits=10, n_repeats=10, random_state=2652124)
            scores = cross_val_score(model, input, label, cv=rkf );
            print(f"model accuracy with c={c} and gamma={gamma} is: {scores.mean()*100} percent")
            accs.append(scores.mean())
            vars.append(scores.var())
            if (scores.mean() > best_acc):
                best_c = c
                best_gamma = gamma
                best_acc = scores.mean()
    print(f"best performance of {best_acc * 100}% was achieved using c={best_c}, gamma={best_gamma}")
    return accs, best_c, best_gamma, best_acc, vars

#plotting the performance of model using different parameters
def Plot_Cs_Gammas(accs):
    subplots = []
    for i in range(8):
        subplots.append(accs[(i*8) : ((i+1)*8)])

    fig, axs = plt.subplots(2, 4)
    fig.set_figheight(10)
    fig.set_figwidth(30)
    axs[0, 0].plot(subplots[0], c = 'red')
    axs[0, 0].set_title('C = 0.01')

    axs[0, 1].plot(subplots[1], c = 'orange')
    axs[0, 1].set_title('C = 0.04')

    axs[0, 2].plot(subplots[2], c = 'green')
    axs[0, 2].set_title('C = 0.1')

    axs[0, 3].plot(subplots[3], c = 'magenta')
    axs[0, 3].set_title('C = 0.4')

    axs[1, 0].plot(subplots[4], c = 'blue')
    axs[1, 0].set_title('C = 1')

    axs[1, 1].plot(subplots[5], c = 'purple')
    axs[1, 1].set_title('C = 4')

    axs[1, 2].plot(subplots[6], c = 'brown')
    axs[1, 2].set_title('C = 10')

    axs[1, 3].plot(subplots[7], c = 'black')
    axs[1, 3].set_title('C = 40')

#plot decision boundary of dataset2
def Decision_Boundary(input, label, best_c, best_gamma):
    x_min, x_max = input[:, 0].min() - 1, input[:, 0].max() + 1
    y_min, y_max = input[:, 1].min() - 1, input[:, 1].max() + 1

    xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))
    model = SVC(kernel='rbf', C=best_c, gamma=best_gamma)
    model.fit(input, label)
    zz = model.predict(np.c_[xx.ravel(), yy.ravel()])
    zz = zz.reshape(xx.shape)


    pos_inputs = []
    neg_inputs = []
    for i in range(len(label)):
        if label[i] == 0:
            neg_inputs.append(input[i, :])
        else:
            pos_inputs.append(input[i, :])

    pos_inputs = np.asarray(pos_inputs)
    neg_inputs = np.asarray(neg_inputs)

    np.shape(pos_inputs)
    plt.scatter(pos_inputs[:, 0], pos_inputs[:, 1], c = 'red')
    plt.scatter(neg_inputs[:, 0], neg_inputs[:, 1], c = 'blue')

    plt.contourf(xx, yy, zz, alpha=0.5, cmap='jet')
    plt.xlim(xx.min() + 0.95, xx.max() - 0.86)
    plt.ylim(yy.min() + 0.88, yy.max() - 0.86)
    plt.title('C=40   gamma=0.08')

accs, best_c, best_gamma, best_acc, vars = Best_Parameters(input, label)

Plot_Cs_Gammas(accs)
Plot_Cs_Gammas(vars)

Decision_Boundary(input, label, best_c, best_gamma)